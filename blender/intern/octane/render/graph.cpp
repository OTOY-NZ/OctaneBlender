/*
 * Copyright 2011-2016 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "graph.h"

OCT_NAMESPACE_BEGIN
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderInput::ShaderInput(ShaderNode *parent_, const char *name_, ShaderSocketType type_)
{
  parent = parent_;
  name = name_;
  type = type_;
  link = NULL;
  value = make_float3(0, 0, 0);
}  // ShaderInput()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderOutput::ShaderOutput(ShaderNode *parent_, const char *name_, ShaderSocketType type_)
{
  parent = parent_;
  name = name_;
  type = type_;
}  // ShaderOutput()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderNode::ShaderNode(::OctaneDataTransferObject::OctaneNodeBase *node_)
{
  oct_node = node_;
  // name    = name_;
  id = -1;
}  // ShaderNode()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderNode::~ShaderNode()
{
  vector<ShaderInput *>::iterator it_in;
  for (it_in = inputs.begin(); it_in != inputs.end(); ++it_in)
    delete *it_in;

  vector<ShaderOutput *>::iterator it_out;
  for (it_out = outputs.begin(); it_out != outputs.end(); ++it_out)
    delete *it_out;

  if (oct_node)
    delete oct_node;
}  //~ShaderNode()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderInput *ShaderNode::input(const char *name)
{
  vector<ShaderInput *>::iterator it;
  for (it = inputs.begin(); it != inputs.end(); ++it) {
    ShaderInput *socket = *it;
    if (strcmp(socket->name, name) == 0)
      return socket;
  }
  return 0;
}  // input()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderOutput *ShaderNode::output(const char *name)
{
  vector<ShaderOutput *>::iterator it;
  for (it = outputs.begin(); it != outputs.end(); ++it) {
    ShaderOutput *socket = *it;
    if (strcmp(socket->name, name) == 0)
      return socket;
  }
  return 0;
}  // output()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderGraph::~ShaderGraph()
{
  list<ShaderNode *>::iterator it;
  for (it = nodes.begin(); it != nodes.end(); ++it)
    delete *it;
}  //~ShaderGraph()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderNode *ShaderGraph::add(ShaderNode *node)
{
  node->id = nodes.size();
  nodes.push_back(node);
  return node;
}  // add()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderNode *ShaderGraph::output()
{
  if (nodes.empty())
    return 0;
  else
    return nodes.front();
}  // output()

bool ShaderGraph::is_builtin_image_updated(ShaderGraph &graph)
{
  for (auto node1 : nodes) {
    OctaneDataTransferObject::OctaneBaseImageNode *image_node1 =
        dynamic_cast<OctaneDataTransferObject::OctaneBaseImageNode *>(node1->oct_node);
    if (image_node1) {
      bool equal = false;
      for (auto node2 : graph.nodes) {
        if (node1->oct_node->sName == node2->oct_node->sName) {
          OctaneDataTransferObject::OctaneBaseImageNode *image_node2 =
              dynamic_cast<OctaneDataTransferObject::OctaneBaseImageNode *>(node2->oct_node);
          if (image_node2) {
            if (image_node1->oImageData.sImageDataMD5Hex ==
                image_node2->oImageData.sImageDataMD5Hex) {
              equal = true;
              break;
			} 
		  }
        }
      }
      if (!equal) {
        return true;
	  }
    }
  }
  return false;
}

std::string ShaderGraph::generate_dependent_name(std::string name, DependentIDType dependent_id_type)
{
  std::string dependent_id_tag = std::to_string(dependent_id_type) + "###";
  return dependent_id_tag + name;
}

void ShaderGraph::add_dependent_name(std::string name, DependentIDType dependent_id_type)
{
  dependent_names.insert(generate_dependent_name(name, dependent_id_type));
}

OCT_NAMESPACE_END
